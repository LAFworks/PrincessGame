<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///menu options

//replace "temp" with actual menu options
menu[0,0] = "Attack";
menu[0,1] = "Heal";
menu[0,2] = "Run";

menu[1,0] = string(global.e1_name);
menu[1,1] = string(global.e2_name);
menu[1,2] = string(global.e3_name);
menu[1,3] = string(global.e4_name);
menu[1,4] = string(global.e5_name);

//vertical space between menu items, for drawing's sake
space = 64;
//menu sprite position 
mpos = 0;

text =1;

global.screen = 0;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>isYourTurn= false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///cursor movement on menu

var move = 0;
//moves along y-coordinates (up and down)
move -= max(keyboard_check_pressed(vk_up), keyboard_check_pressed(ord("W")),0);

//x-coord
move += max(keyboard_check_pressed(vk_down), keyboard_check_pressed(ord("S")),0);

if (move != 0)
{
    mpos += move;
    //wrap around for out-of-bounds
    if (mpos &lt; 0)
    {
        mpos = array_length_2d(menu, global.screen) -1;
    }
    if (mpos &gt; array_length_2d(menu, global.screen) -1)
    { 
        mpos = 0
    }
}

/*if keyboard_check_pressed(ord("W"))
{
    mpos -= 1;
    if mpos &lt; 0
    {
        mpos = array_length_1d(menu)-1;
    }
}

if keyboard_check_pressed(ord("S"))
{
    mpos += 1;
    if mpos &gt; array_length_1d(menu)
    {
        mpos = 0;
    }
}*/

if turn == global.p1_turn and text == 1
{
    show_debug_message("It is Player 1's Turn");
    text =0;
}
if turn == global.p2_turn and text == 1
{
    show_debug_message("It is Player 2's Turn");
    text= 0;
}
if turn == global.p3_turn and text == 1
{
    show_debug_message("It is Player 3's Turn");
    text = 0;
}

var push;
push = max(keyboard_check_released(vk_enter),keyboard_check_released(vk_shift),keyboard_check_released(vk_space), 0);

if (push == 1)
{
    scr_menu();
}

//If it is the enemies turn do their attacks/actions
//This should allow players to traverse the menu during enemy combat
if turn == e1_turn and !isYourTurn
{
    if !instance_exists(Enemy)  //Checks to make sure the enemy is still there
    {
        if (turn ==8)
        {
            turn =1;
        }
        else
        {
           turn+=1;
        }
    }
    
    else
    {
        isYourTurn = true;
        while true
        { 
            target= irandom(2)
            if target == 0 and instance_exists(Player)
            {
                global.p1_health -= global.e1_attack;
                alarm[0] = 120; //Moves turn to next in list with delay
                show_debug_message(string("It's the first Snake's turn"));
                show_debug_message("Attacked Player1 for "+string(global.e1_attack)+ " damage.");
                show_debug_message("Player1 has " +string(global.p1_health)+ " left.");
                break;
            }
            else if target == 1 and instance_exists(Player2)
            {
                global.p2_health -= global.e1_attack;  //Damage calc
                alarm[0] = 120;
                show_debug_message("It is the first Snake's turn");
                show_debug_message("Attacked Player2 for "+string(global.e1_attack)+ " damage.");
                show_debug_message("Player2 has " +string(global.p2_health)+ " left.");
                break;
            }
            else if target == 2 and instance_exists(Player3)
            {
                global.p3_health -= global.e1_attack;  //Damage calc
                alarm[0] = 120;
                show_debug_message(string("It is the first snakes turn"));
                show_debug_message("Attacked Player3 for "+string(global.e1_attack)+ " damage.");
                show_debug_message("Player3 has " +string(global.p3_health)+ " left.");
                break;
            }
        }
        if (turn ==8)
        {
            turn =1;
        }
        else
        {
            turn+=1;
        }
    }
}

if turn == e2_turn and !isYourTurn
{
    if !instance_exists(Enemy2)  //Checks to make sure the enemy is still there
    {
        if (turn ==8)
        {
            turn =1;
        }
        else
        {
           turn+=1;
        }
    }
    
    else
    {
        isYourTurn = true;
        while true
        { 
            target= irandom(2)
            if target == 0 and instance_exists(Player)
            {
                global.p1_health -= global.e2_attack;
                alarm[0] = 120; //Moves turn to next in list with delay
                show_debug_message(string("It's the second Snake's turn"));
                show_debug_message("Attacked Player1 for "+string(global.e2_attack)+ " damage.");
                show_debug_message("Player1 has " +string(global.p1_health)+ " left.");
                break;
            }
            else if target == 1 and instance_exists(Player2)
            {
                global.p2_health -= global.e2_attack;  //Damage calc
                alarm[0] = 120;
                show_debug_message(string("It's the second Snake's turn"));
                show_debug_message("Attacked Player2 for "+string(global.e2_attack)+ " damage.");
                show_debug_message("Player2 has " +string(global.p2_health)+ " left.");
                break;
            }
            else if target == 2 and instance_exists(Player3)
            {
                global.p3_health -= global.e2_attack;  //Damage calc
                alarm[0] = 120;
                show_debug_message(string("It's the second Snake's turn"));
                show_debug_message("Attacked Player3 for "+string(global.e2_attack)+ " damage.");
                show_debug_message("Player3 has " +string(global.p3_health)+ " left.");
                break;
            }
        }
        if (turn ==8)
        {
            turn =1;
        }
        else
        {
            turn+=1;
        }
    }
}

if turn == e3_turn and !isYourTurn
{
    if !instance_exists(Enemy3)  //Checks to make sure the enemy is still there
    {
        if (turn ==8)
        {
            turn =1;
        }
        else
        {
           turn+=1;
        }
    }
    
    else
    {
        isYourTurn = true;
        while true
        { 
            target= irandom(2)
            if target == 0 and instance_exists(Player)
            {
                global.p1_health -= global.e3_attack;
                alarm[0] = 120; //Moves turn to next in list with delay
                show_debug_message(string("It's the third Snake's turn"));
                show_debug_message("Attacked Player1 for "+string(global.e3_attack)+ " damage.");
                show_debug_message("Player1 has " +string(global.p1_health)+ " left.");
                break;
            }
            else if target == 1 and instance_exists(Player2)
            {
                global.p2_health -= global.e3_attack;  //Damage calc
                alarm[0] = 120;
                show_debug_message(string("It's the third Snake's turn"));
                show_debug_message("Attacked Player2 for "+string(global.e3_attack)+ " damage.");
                show_debug_message("Player2 has " +string(global.p2_health)+ " left.");
                break;
            }
            else if target == 2 and instance_exists(Player3)
            {
                global.p3_health -= global.e3_attack;  //Damage calc
                alarm[0] = 120;
                show_debug_message(string("It's the third Snake's turn"));
                show_debug_message("Attacked Player3 for "+string(global.e3_attack)+ " damage.");
                show_debug_message("Player3 has " +string(global.p3_health)+ " left.");
                break;
            }
        }
        if (turn ==8)
        {
            turn =1;
        }
        else
        {
            turn+=1;
        }
    }
}

if turn == e4_turn and !isYourTurn
{
    if !instance_exists(Enemy4)  //Checks to make sure the enemy is still there
    {
        if (turn ==8)
        {
            turn =1;
        }
        else
        {
           turn+=1;
        }
    }
    
    else
    {
        isYourTurn = true;
        while true
        { 
            target= irandom(2)
            if target == 0 and instance_exists(Player)
            {
                global.p1_health -= global.e4_attack;
                alarm[0] = 120; //Moves turn to next in list with delay
                show_debug_message(string("It's the fourth Snake's turn"));
                show_debug_message("Attacked Player1 for "+string(global.e4_attack)+ " damage.");
                show_debug_message("Player1 has " +string(global.p1_health)+ " left.");
                break;
            }
            else if target == 1 and instance_exists(Player2)
            {
                global.p2_health -= global.e4_attack;  //Damage calc
                alarm[0] = 120;
                show_debug_message(string("It's the fourth Snake's turn"));
                show_debug_message("Attacked Player2 for "+string(global.e4_attack)+ " damage.");
                show_debug_message("Player2 has " +string(global.p2_health)+ " left.");
                break;
            }
            else if target == 2 and instance_exists(Player3)
            {
                global.p3_health -= global.e4_attack;  //Damage calc
                alarm[0] = 120;
                show_debug_message(string("It's the fourth Snake's turn"));
                show_debug_message("Attacked Player3 for "+string(global.e4_attack)+ " damage.");
                show_debug_message("Player3 has " +string(global.p3_health)+ " left.");
                break;
            }
        }
        if (turn ==8)
        {
            turn =1;
        }
        else
        {
            turn+=1;
        }
    }
}

if turn == e5_turn and !isYourTurn
{
    if !instance_exists(Enemy5)  //Checks to make sure the enemy is still there
    {
        if (turn ==8)
        {
            turn =1;
        }
        else
        {
           turn+=1;
        }
    }
    
    else
    {
        isYourTurn = true;
        while true
        { 
            target= irandom(2)
            if target == 0 and instance_exists(Player)
            {
                global.p1_health -= global.e5_attack;
                alarm[0] = 120; //Moves turn to next in list with delay
                show_debug_message(string("It's the fifth Snake's turn"));
                show_debug_message("Attacked Player1 for "+string(global.e5_attack)+ " damage.");
                show_debug_message("Player1 has " +string(global.p1_health)+ " left.");
                break;
            }
            else if target == 1 and instance_exists(Player2)
            {
                global.p2_health -= global.e5_attack;  //Damage calc
                alarm[0] = 120;
                show_debug_message(string("It's the fifth Snake's turn"));
                show_debug_message("Attacked Player2 for "+string(global.e5_attack)+ " damage.");
                show_debug_message("Player2 has " +string(global.p2_health)+ " left.");
                break;
            }
            else if target == 2 and instance_exists(Player3)
            {
                global.p3_health -= global.e5_attack;  //Damage calc
                alarm[0] = 120;
                show_debug_message(string("It's the fifth Snake's turn"));
                show_debug_message("Attacked Player3 for "+string(global.e5_attack)+ " damage.");
                show_debug_message("Player3 has " +string(global.p3_health)+ " left.");
                break;
            }
        }
        if (turn ==8)
        {
            turn =1;
        }
        else
        {
            turn+=1;
        }
    }
}

//For now use existence to check comabt encounter ending
//Replace later with variable for num enemies/players?
if !instance_exists(Enemy) and !instance_exists(Enemy2) and !instance_exists(Enemy3) and !instance_exists(Enemy4) and !instance_exists(Enemy5)
{
    show_debug_message("You Win!");
    global.has_triggered =true;
    alarm[5]= 150;
    room_goto(rm_overworld);
}

else if !instance_exists(Player) and !instance_exists(Player2) and !instance_exists(Player3)
{
    show_debug_message("You lose!");
    global.has_triggered =true;
    alarm[5]= 150;
    room_goto(rm_overworld);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>isYourTurn = false;
//Future sorting algorithm for speed stats
//Enemyturn= 1;
//Player1turn= 2;
//Player2turn= 3;
turn= 1;
n=1;
place = 0;

turn_order = ds_list_create();
ds_list_add(turn_order, global.p1_speed, global.p2_speed, global.p3_speed, global.e1_speed, global.e2_speed, global.e3_speed, global.e4_speed, global.e5_speed);
ds_list_sort(turn_order, false);

copy = ds_list_create();
ds_list_copy(copy, turn_order);

global.p1_turn = ds_list_find_index(turn_order, global.p1_speed);
place = global.p1_turn;
if (ds_list_find_value(copy, global.p1_turn) == noone)
{
    global.p1_turn += n+1;
    n += 1;
}
else
{
    global.p1_turn += 1;
    n = 1;
}
ds_list_replace(copy, place, noone);
show_debug_message(string(global.p1_turn));


global.p2_turn = ds_list_find_index(turn_order, global.p2_speed);
place = global.p2_turn;
if (ds_list_find_value(copy, global.p2_turn) == noone)
{
    global.p2_turn += n+1;
    n += 1;
}
else
{
    global.p2_turn += 1;
    n = 1;
}
ds_list_replace(copy, place, noone);
show_debug_message(string(global.p2_turn));


global.p3_turn = ds_list_find_index(turn_order, global.p3_speed);
place = global.p3_turn;
if (ds_list_find_value(copy, global.p3_turn) == noone)
{
    global.p3_turn += n+1;
    n += 1;
}
else
{
    global.p3_turn += 1;
    n = 1;
}
ds_list_replace(copy, place, noone);
show_debug_message(string(global.p3_turn));

e1_turn = ds_list_find_index(turn_order, global.e1_speed);
place = e1_turn;
if (ds_list_find_value(copy, e1_turn) == noone)
{
    e1_turn += n+1;
    n += 1;
}
else
{
    e1_turn += 1;
    n = 1;
}
ds_list_replace(copy, place, noone);
show_debug_message(string(e1_turn));


e2_turn = ds_list_find_index(turn_order, global.e2_speed);
place = e2_turn;
if (ds_list_find_value(copy, e2_turn) == noone)
{
    e2_turn += n+1;
    n += 1;
}
else
{
    e2_turn += 1;
    n = 1;
}
ds_list_replace(copy, place, noone);
show_debug_message(string(e2_turn));


e3_turn = ds_list_find_index(turn_order, global.e3_speed);
place = e3_turn;
if (ds_list_find_value(copy, e3_turn) == noone)
{
    e3_turn += n+1;
    n += 1;
}
else
{
    e3_turn += 1;
    n = 1;
}
ds_list_replace(copy, place, noone);
show_debug_message(string(e3_turn));


e4_turn = ds_list_find_index(turn_order, global.e4_speed);
place = e4_turn;
if (ds_list_find_value(copy, e4_turn) == noone)
{
    e4_turn += n+1;
    n += 1;
}
else
{
    e4_turn += 1;
    n = 1;
}
ds_list_replace(copy, place, noone);
show_debug_message(string(e4_turn));


e5_turn = ds_list_find_index(turn_order, global.e5_speed);
place = e5_turn;
if (ds_list_find_value(copy, e5_turn) == noone)
{
    e5_turn += n+1;
    n += 1;
}
else
{
    e5_turn += 1;
    n = 1;
}
ds_list_replace(copy, place, noone);
show_debug_message(string(e5_turn));







</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Padding for inside dialogue box
var padding = 10;

// sample text for spacing purposes
var sampleTxt = "sample";
var sTxt_height = string_height(sampleTxt)*2;

//Max width &amp; height
max_width = view_wview - (padding*2);
max_height = (view_hview/4)-(.25*(view_hview/4));

// Draw Variables
draw_set_font(fnt_temp);

// Draw dialogue box
draw_set_color(c_black);
draw_rectangle(view_xview,((view_yview+view_hview)-max_height)-(padding*1.5),view_wview,view_yview+view_hview,false);

// Rectangle Borders
var bw = 4; // Border width
draw_set_color(c_white);
draw_line_width(view_xview, ((view_yview+view_hview)-max_height)-(padding*1.5), view_xview, (view_yview+view_hview), bw);
draw_line_width(view_xview-(bw/2), ((view_yview+view_hview)-max_height)-(padding*1.5), view_xview+view_wview, ((view_yview+view_hview)-max_height)-(padding*1.5), bw);
draw_line_width(view_xview+view_wview-bw/2, ((view_yview+view_hview)-max_height)-(padding*1.5), view_xview+view_wview-bw/2, (view_yview+view_hview), bw);
draw_line_width(view_xview, (view_yview+view_hview)-bw/2, view_xview+view_wview, (view_yview+view_hview)-bw/2, bw);

//draw menu items
var m 
var menuHeight = 600
for (m = 0; m &lt; array_length_2d(menu, global.screen); m+= 1)
{
    if global.screen == 0
    {    
        menuHeight += 40;
    }
    else
    {
        menuHeight += 20;
    }
    //draw_text(x + space, y + (m * space), string(menu[m]));
    // TODO fix this code to restrict menu options to interior of borders ^
    
     if (mpos = m)
     {
        draw_set_color(c_red);
     }
     else
     {
        draw_set_color(c_white);
     }
    
     draw_text_ext(view_xview+padding,menuHeight,menu[global.screen, m],sTxt_height,max_width);

    
}
//TODO create sprite for menu item chooser
//draw_sprite(sprite_index, 0, x + 16, y+pos*space);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
